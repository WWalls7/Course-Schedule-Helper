{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Swizzle\\\\Desktop\\\\SE Project\\\\Application\\\\csh\\\\src\\\\components\\\\Calendar.js\";\nimport React, { Component } from 'react';\nimport moment from 'moment';\nimport ReactResizeDetector from 'react-resize-detector';\nimport CalendarFrame from '../components/calendar';\nimport { MULTI_DAY_TYPE, PLACEHOLDER_TYPE, SINGLE_DAY_TYPE, wrappingTiles } from \"../resources/values/strings\";\nimport { parseConfig, parseEvent, reorderEvents, wrapLongEvent, computeDifferences } from \"../resources/utilities\";\n\nclass Calendar extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      calendarList: null,\n      isLoading: true,\n      month: 0,\n      year: 0,\n      numDaysInMonth: 0,\n      isMobile: false,\n      frameRef: React.createRef()\n    };\n    this.initCalendarList = this.initCalendarList.bind(this);\n    this.loadEvent = this.loadEvent.bind(this);\n    this.loadCalendarList = this.loadCalendarList.bind(this);\n  }\n  /*\r\n   * Load events and config props from the parent component. Events here are copied so that when we determine the\r\n   * event type in the loadCalendarList function, we do not mutate the passed events which may have other uses in\r\n   * their program.\r\n   *\r\n   * parseConfig checks for missing data members such as colors or weekdays, and injects default values for those\r\n   * fields into the config object. This ensures calendar events will always be colored.\r\n   */\n\n\n  componentDidMount() {\n    const {\n      items,\n      config,\n      month,\n      year\n    } = this.props; // Create deep copy so that user input is not mutated.\n\n    let eventsCopy = JSON.parse(JSON.stringify(items)); // Inject defaults if key is not overwritten.\n\n    parseConfig(config);\n    let safeMonth = month ? month : new Date().getMonth() + 1;\n    let safeYear = year ? year : new Date().getFullYear();\n    this.initCalendarList(safeMonth, safeYear, () => {\n      this.loadCalendarList(eventsCopy, safeMonth, safeYear);\n    });\n  }\n\n  componentWillReceiveProps(nextProps, nextContext) {\n    if ((nextProps.month !== this.props.month || nextProps.year !== this.props.year) && nextProps.items) {\n      const {\n        items,\n        config,\n        month,\n        year\n      } = nextProps; // Create deep copy so that user input is not mutated.\n\n      let eventsCopy = JSON.parse(JSON.stringify(items)); // Inject defaults if key is not overwritten.\n\n      parseConfig(config);\n      let safeMonth = month ? month : new Date().getMonth() + 1;\n      let safeYear = year ? year : new Date().getFullYear();\n      this.initCalendarList(safeMonth, safeYear, () => {\n        this.loadCalendarList(eventsCopy, safeMonth, safeYear);\n      });\n    }\n  }\n  /*\r\n   * Initialize empty calendar list of a given length. This step is important because it allows us to use unshift\r\n   * functions to load our events without worrying about the calendar index being undefined.\r\n   *\r\n   * This is the starting point of the calendar, and everything flows from here.\r\n   * initCalendarList -> loadCalendarList -> loadEvent -> calendarList passed to presentational components and displayed.\r\n   *\r\n   * @param callBack: This callBack is the loadCalendarList function. Once the calendar has been initialized,\r\n   *                  we can begin loading it.\r\n   */\n\n\n  initCalendarList(month, year, callBack) {\n    const numDaysInMonth = [31, year % 4 === 0 ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let calendarList = [];\n    let numDays = numDaysInMonth[month - 1];\n    let offset = moment(`${year}-${month}-01`, 'YYYY-M-DD').day();\n    let numTiles = offset + numDays > 35 ? 35 + 7 : 35;\n\n    for (let i = 0; i < numTiles; i++) {\n      calendarList[i] = [];\n    }\n\n    this.setState({\n      calendarList,\n      numDaysInMonth\n    }, () => callBack());\n  }\n  /* Sort and iterate over copied events, assigning types and determining their place on the calendar.\r\n   * numDays, offset, and most of the variables below are used to calculate the event's position from it's start\r\n   * and end dates.\r\n   */\n\n\n  loadCalendarList(events, month, year) {\n    // Six weeks, four weeks = selected month, one week for months before and after - 42 days total.\n    // Group events on the same day, each element in array represents one day.\n    const {\n      calendarList,\n      numDaysInMonth\n    } = this.state;\n    const {\n      config\n    } = this.props;\n    if (!config) return null;\n    let firstDateStart = null,\n        firstDateEnd = null;\n    let secondDateStart = null,\n        secondDateEnd = null;\n    let firstDateCreated = null,\n        secondDateCreated = null;\n    let numDays = numDaysInMonth[month - 1];\n    let numDaysInLastMonth = numDaysInMonth[month - 2 >= 0 ? month - 2 : 11];\n    let numDaysInNextMonth = numDaysInMonth[month > 11 ? 0 : month];\n    let offset = moment(`${year}-${month}-01`, \"YYYY-M-DD\").day();\n    let numTiles = offset + numDays > 35 ? 35 + 7 : 35;\n    let argsObject = {\n      numDays,\n      numDaysInMonth,\n      numDaysInLastMonth,\n      numDaysInNextMonth,\n      offset,\n      month,\n      year,\n      numTiles\n    };\n    events.sort((firstEvent, secondEvent) => {\n      firstDateCreated = moment(firstEvent.created);\n      secondDateCreated = moment(secondEvent.created);\n      firstDateStart = moment(firstEvent.start, config.dateFormat);\n      firstDateEnd = moment(firstEvent.end, config.dateFormat);\n      secondDateStart = moment(secondEvent.start, config.dateFormat);\n      secondDateEnd = moment(secondEvent.end, config.dateFormat);\n      const args = {\n        firstDateStart,\n        firstDateEnd,\n        secondDateStart,\n        secondDateEnd,\n        month,\n        numDaysInMonth\n      };\n      return computeDifferences(firstDateCreated, secondDateCreated, firstEvent, secondEvent, args);\n    });\n    events.map(event => {\n      const {\n        parsedDay,\n        parsedEnd,\n        parsedMonth,\n        parsedMonthEnd,\n        isBelowEventRange,\n        isAboveEventRange\n      } = parseEvent(event, argsObject, config);\n      const parts = {\n        numTiles,\n        parsedDay,\n        parsedEnd,\n        offset,\n        month,\n        numDaysInLastMonth,\n        numDays\n      };\n\n      if (!isBelowEventRange || !isAboveEventRange) {\n        for (let i = parsedDay, j = 0; i < parsedEnd; i++, j++) {\n          switch (true) {\n            // Event is multiple days long\n            case Math.abs(parsedEnd - parsedDay) > 1:\n              event.type = MULTI_DAY_TYPE;\n              break;\n            // Event takes place over a single day\n\n            case parsedMonth === parsedMonthEnd ? Math.abs(parsedEnd - parsedDay) <= 1 : Math.abs(parsedEnd - parsedDay - parsedDay) <= 1:\n              event.type = SINGLE_DAY_TYPE;\n              break;\n            // If event reaches here, there is likely something wrong with its structure.\n            // Set it as a placeholder so it is less likely to disrupt other events.\n\n            default:\n              event.type = PLACEHOLDER_TYPE;\n              break;\n          }\n\n          switch (true) {\n            // Event belongs to 'this' month\n            case parsedMonth === month:\n              this.loadEvent(event, calendarList, i + offset - 1, parts, j);\n              break;\n            // Event belongs to previous month\n\n            case parsedMonth === (month - 1 >= 1 ? month - 1 : 12):\n              this.loadEvent(event, calendarList, i - numDaysInLastMonth + offset - 1, parts, j);\n              break;\n            // Event belongs to next month\n\n            default:\n              this.loadEvent(event, calendarList, numDays + i + offset - 1, parts, j);\n              break;\n          }\n        }\n      }\n\n      return 0; // Get rid of warning\n    }); // Perform second pass to reorder placeholder events so that space can be saved.\n\n    reorderEvents({\n      calendarList,\n      numDays,\n      numDaysInMonth,\n      numDaysInLastMonth,\n      numDaysInNextMonth,\n      offset,\n      month,\n      year,\n      numTiles,\n      config\n    });\n    this.setState({\n      calendarList,\n      isLoading: false,\n      month,\n      year\n    });\n  }\n  /* Place event into appropriate spot on calendar, check for vertical overflow, and wrap events that extend past\r\n   * calendar border.\r\n   *\r\n   * This is the last step before the calendarList is passed to the presentational components.\r\n   */\n\n\n  loadEvent(event, calendarList, i, parts, j) {\n    const {\n      config\n    } = this.props;\n    const {\n      parsedEnd,\n      numTiles\n    } = parts;\n    let ranOnce = false;\n\n    if (i >= 0 && i < numTiles && j === 0) {\n      calendarList[i].unshift(event);\n      wrapLongEvent(event, ranOnce, calendarList, parts, i, event, config);\n    } else {\n      let start = moment(event.start, config.dateFormat);\n      let end = moment(event.end, config.dateFormat);\n\n      if (i >= 0 && i < numTiles) {\n        if (!wrappingTiles.includes(i - 1)) {\n          calendarList[i].unshift({\n            summary: event.summary,\n            created: event.created,\n            type: PLACEHOLDER_TYPE,\n            start: {\n              date: `${start.year()}-${start.month() + 1}-${parsedEnd}`\n            },\n            end: {\n              date: `${end.year()}-${end.month() + 1}-${parsedEnd}`\n            }\n          });\n        }\n      }\n    }\n  }\n  /* Calendar will shrink into mobile mode when the calendar's container is below a certain height or width.\r\n   * Width and height values are determined to be the lowest values possible and still retain calendar integrity.\r\n   */\n\n\n  checkParentDimensions(ref) {\n    let width = ref.current.clientWidth;\n    let height = ref.current.clientHeight;\n\n    if (width < 451 || height < 521) {\n      this.setState({\n        isMobile: true\n      });\n    } else {\n      this.setState({\n        isMobile: false\n      });\n    }\n  }\n\n  render() {\n    const {\n      config\n    } = this.props;\n    const {\n      calendarList,\n      isLoading,\n      month,\n      year,\n      numDaysInMonth,\n      isMobile,\n      frameRef\n    } = this.state;\n\n    if (isLoading) {\n      return React.createElement(\"div\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 287\n        },\n        __self: this\n      });\n    } // Patch for leap years since year value is dynamic.\n\n\n    config.numDaysInMonth = numDaysInMonth;\n    config.isMobile = isMobile;\n    return React.createElement(\"div\", {\n      className: \"calendar-frame\",\n      ref: frameRef,\n      style: {\n        height: config.height,\n        width: config.width\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 294\n      },\n      __self: this\n    }, React.createElement(CalendarFrame, {\n      year: year,\n      month: month,\n      calendarList: calendarList,\n      config: config,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 295\n      },\n      __self: this\n    }), React.createElement(ReactResizeDetector, {\n      handleHeight: true,\n      handleWidth: true,\n      onResize: () => this.checkParentDimensions(frameRef),\n      refreshMode: 'debounce',\n      refreshRate: 200,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 296\n      },\n      __self: this\n    }));\n  }\n\n}\n\nexport const EventCalendar = Calendar;\nexport const eventTypes = {\n  PLACEHOLDER_TYPE,\n  MULTI_DAY_TYPE,\n  SINGLE_DAY_TYPE\n};","map":{"version":3,"sources":["C:/Users/Swizzle/Desktop/SE Project/Application/csh/src/components/Calendar.js"],"names":["React","Component","moment","ReactResizeDetector","CalendarFrame","MULTI_DAY_TYPE","PLACEHOLDER_TYPE","SINGLE_DAY_TYPE","wrappingTiles","parseConfig","parseEvent","reorderEvents","wrapLongEvent","computeDifferences","Calendar","constructor","props","state","calendarList","isLoading","month","year","numDaysInMonth","isMobile","frameRef","createRef","initCalendarList","bind","loadEvent","loadCalendarList","componentDidMount","items","config","eventsCopy","JSON","parse","stringify","safeMonth","Date","getMonth","safeYear","getFullYear","componentWillReceiveProps","nextProps","nextContext","callBack","numDays","offset","day","numTiles","i","setState","events","firstDateStart","firstDateEnd","secondDateStart","secondDateEnd","firstDateCreated","secondDateCreated","numDaysInLastMonth","numDaysInNextMonth","argsObject","sort","firstEvent","secondEvent","created","start","dateFormat","end","args","map","event","parsedDay","parsedEnd","parsedMonth","parsedMonthEnd","isBelowEventRange","isAboveEventRange","parts","j","Math","abs","type","ranOnce","unshift","includes","summary","date","checkParentDimensions","ref","width","current","clientWidth","height","clientHeight","render","EventCalendar","eventTypes"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport moment from 'moment';\r\nimport ReactResizeDetector from 'react-resize-detector';\r\n\r\nimport CalendarFrame from '../components/calendar';\r\nimport {\r\n    MULTI_DAY_TYPE,\r\n    PLACEHOLDER_TYPE, SINGLE_DAY_TYPE,\r\n    wrappingTiles\r\n} from \"../resources/values/strings\";\r\nimport {\r\n    parseConfig,\r\n    parseEvent,\r\n    reorderEvents,\r\n    wrapLongEvent,\r\n    computeDifferences\r\n} from \"../resources/utilities\";\r\n\r\nclass Calendar extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            calendarList: null,\r\n            isLoading: true,\r\n            month: 0,\r\n            year: 0,\r\n            numDaysInMonth: 0,\r\n            isMobile: false,\r\n            frameRef: React.createRef(),\r\n        };\r\n\r\n        this.initCalendarList = this.initCalendarList.bind(this);\r\n        this.loadEvent = this.loadEvent.bind(this);\r\n        this.loadCalendarList = this.loadCalendarList.bind(this);\r\n    }\r\n\r\n    /*\r\n     * Load events and config props from the parent component. Events here are copied so that when we determine the\r\n     * event type in the loadCalendarList function, we do not mutate the passed events which may have other uses in\r\n     * their program.\r\n     *\r\n     * parseConfig checks for missing data members such as colors or weekdays, and injects default values for those\r\n     * fields into the config object. This ensures calendar events will always be colored.\r\n     */\r\n    componentDidMount() {\r\n        const { items, config, month, year } = this.props;\r\n\r\n        // Create deep copy so that user input is not mutated.\r\n        let eventsCopy  = JSON.parse(JSON.stringify(items));\r\n\r\n        // Inject defaults if key is not overwritten.\r\n        parseConfig(config);\r\n\r\n        let safeMonth = month ? month : new Date().getMonth() + 1;\r\n        let safeYear = year ? year : new Date().getFullYear();\r\n\r\n        this.initCalendarList(safeMonth, safeYear, () => {\r\n            this.loadCalendarList(eventsCopy, safeMonth, safeYear);\r\n        });\r\n    }\r\n\r\n    componentWillReceiveProps(nextProps, nextContext) {\r\n        if ( (nextProps.month !== this.props.month || nextProps.year !== this.props.year) && nextProps.items) {\r\n            const { items, config, month, year } = nextProps;\r\n\r\n            // Create deep copy so that user input is not mutated.\r\n            let eventsCopy  = JSON.parse(JSON.stringify(items));\r\n\r\n            // Inject defaults if key is not overwritten.\r\n            parseConfig(config);\r\n\r\n            let safeMonth = month ? month : new Date().getMonth() + 1;\r\n            let safeYear = year ? year : new Date().getFullYear();\r\n\r\n            this.initCalendarList(safeMonth, safeYear, () => {\r\n                this.loadCalendarList(eventsCopy, safeMonth, safeYear);\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Initialize empty calendar list of a given length. This step is important because it allows us to use unshift\r\n     * functions to load our events without worrying about the calendar index being undefined.\r\n     *\r\n     * This is the starting point of the calendar, and everything flows from here.\r\n     * initCalendarList -> loadCalendarList -> loadEvent -> calendarList passed to presentational components and displayed.\r\n     *\r\n     * @param callBack: This callBack is the loadCalendarList function. Once the calendar has been initialized,\r\n     *                  we can begin loading it.\r\n     */\r\n    initCalendarList(month, year, callBack) {\r\n        const numDaysInMonth = [31, year % 4 === 0 ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\r\n        let calendarList = [];\r\n\r\n        let numDays = numDaysInMonth[month - 1];\r\n        let offset = moment(`${year}-${month}-01`, 'YYYY-M-DD').day();\r\n        let numTiles = offset + numDays > 35 ? 35 + 7 : 35;\r\n\r\n        for (let i = 0; i < numTiles ; i++) {\r\n            calendarList[i] = [];\r\n        }\r\n\r\n        this.setState({ calendarList, numDaysInMonth }, () => callBack());\r\n\r\n    }\r\n\r\n    /* Sort and iterate over copied events, assigning types and determining their place on the calendar.\r\n     * numDays, offset, and most of the variables below are used to calculate the event's position from it's start\r\n     * and end dates.\r\n     */\r\n    loadCalendarList(events, month, year) {\r\n        // Six weeks, four weeks = selected month, one week for months before and after - 42 days total.\r\n        // Group events on the same day, each element in array represents one day.\r\n        const { calendarList, numDaysInMonth } = this.state;\r\n        const { config } = this.props;\r\n\r\n        if (!config) return null;\r\n\r\n        let firstDateStart = null, firstDateEnd = null;\r\n        let secondDateStart = null, secondDateEnd = null;\r\n        let firstDateCreated = null, secondDateCreated = null;\r\n\r\n        let numDays = numDaysInMonth[month - 1];\r\n        let numDaysInLastMonth = numDaysInMonth[month - 2 >= 0 ? month - 2 : 11];\r\n        let numDaysInNextMonth = numDaysInMonth[month > 11 ? 0 : month];\r\n        let offset =  moment(`${year}-${month}-01`, \"YYYY-M-DD\").day();\r\n        let numTiles = offset + numDays > 35 ? 35 + 7 : 35;\r\n\r\n        let argsObject = { numDays, numDaysInMonth, numDaysInLastMonth, numDaysInNextMonth, offset, month, year, numTiles };\r\n\r\n        events.sort((firstEvent, secondEvent) => {\r\n\r\n            firstDateCreated = moment(firstEvent.created);\r\n            secondDateCreated = moment(secondEvent.created);\r\n\r\n            firstDateStart = moment(firstEvent.start, config.dateFormat);\r\n            firstDateEnd = moment(firstEvent.end, config.dateFormat);\r\n\r\n            secondDateStart = moment(secondEvent.start, config.dateFormat);\r\n            secondDateEnd = moment(secondEvent.end, config.dateFormat);\r\n\r\n            const args = {\r\n                firstDateStart,\r\n                firstDateEnd,\r\n                secondDateStart,\r\n                secondDateEnd,\r\n                month,\r\n                numDaysInMonth,\r\n            };\r\n\r\n            return computeDifferences(\r\n                firstDateCreated,\r\n                secondDateCreated,\r\n                firstEvent,\r\n                secondEvent,\r\n                args\r\n            );\r\n\r\n        });\r\n\r\n        events.map(event => {\r\n\r\n            const {\r\n                parsedDay,\r\n                parsedEnd,\r\n                parsedMonth,\r\n                parsedMonthEnd,\r\n                isBelowEventRange,\r\n                isAboveEventRange\r\n            } = parseEvent(event, argsObject, config);\r\n\r\n            const parts = {\r\n                numTiles,\r\n                parsedDay,\r\n                parsedEnd,\r\n                offset,\r\n                month,\r\n                numDaysInLastMonth,\r\n                numDays,\r\n            };\r\n\r\n            if (!isBelowEventRange || !isAboveEventRange) {\r\n                for (let i = parsedDay, j = 0 ; i < parsedEnd; i++, j++) {\r\n                    switch(true) {\r\n                        // Event is multiple days long\r\n                        case Math.abs(parsedEnd - parsedDay) > 1:\r\n                            event.type = MULTI_DAY_TYPE;\r\n                            break;\r\n\r\n                        // Event takes place over a single day\r\n                        case parsedMonth === parsedMonthEnd\r\n                            ? Math.abs(parsedEnd - parsedDay) <= 1\r\n                            : Math.abs((parsedEnd - parsedDay) - parsedDay) <= 1:\r\n                            event.type = SINGLE_DAY_TYPE;\r\n                            break;\r\n\r\n                        // If event reaches here, there is likely something wrong with its structure.\r\n                        // Set it as a placeholder so it is less likely to disrupt other events.\r\n                        default:\r\n                            event.type = PLACEHOLDER_TYPE;\r\n                            break;\r\n                    }\r\n\r\n                    switch(true) {\r\n                        // Event belongs to 'this' month\r\n                        case parsedMonth === month:\r\n                            this.loadEvent(event, calendarList, i + offset - 1, parts, j);\r\n                            break;\r\n\r\n                        // Event belongs to previous month\r\n                        case parsedMonth === (month - 1 >= 1 ? month - 1 : 12):\r\n                            this.loadEvent(event, calendarList, i - numDaysInLastMonth + offset - 1, parts, j);\r\n                            break;\r\n\r\n                        // Event belongs to next month\r\n                        default:\r\n                            this.loadEvent(event, calendarList, numDays + i + offset - 1, parts, j);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return 0; // Get rid of warning\r\n        });\r\n\r\n        // Perform second pass to reorder placeholder events so that space can be saved.\r\n        reorderEvents({ calendarList, numDays, numDaysInMonth, numDaysInLastMonth, numDaysInNextMonth, offset, month, year, numTiles, config });\r\n\r\n        this.setState({ calendarList, isLoading: false, month, year });\r\n    }\r\n\r\n    /* Place event into appropriate spot on calendar, check for vertical overflow, and wrap events that extend past\r\n     * calendar border.\r\n     *\r\n     * This is the last step before the calendarList is passed to the presentational components.\r\n     */\r\n    loadEvent(event, calendarList, i, parts, j) {\r\n        const { config } = this.props;\r\n        const { parsedEnd, numTiles } = parts;\r\n        let ranOnce = false;\r\n        if (i >= 0 && i < numTiles && j === 0 ) {\r\n            calendarList[i].unshift(event);\r\n\r\n            wrapLongEvent(event, ranOnce, calendarList, parts, i, event, config);\r\n\r\n        } else {\r\n            let start = moment(event.start, config.dateFormat);\r\n            let end = moment(event.end, config.dateFormat);\r\n\r\n            if (i >= 0 && i < numTiles) {\r\n                if (!wrappingTiles.includes(i - 1)) {\r\n                    calendarList[i].unshift({\r\n                        summary: event.summary,\r\n                        created: event.created,\r\n                        type: PLACEHOLDER_TYPE,\r\n                        start: {date: `${start.year()}-${start.month() + 1}-${parsedEnd}`},\r\n                        end: {date: `${end.year()}-${end.month() + 1}-${parsedEnd}`}\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Calendar will shrink into mobile mode when the calendar's container is below a certain height or width.\r\n     * Width and height values are determined to be the lowest values possible and still retain calendar integrity.\r\n     */\r\n    checkParentDimensions(ref) {\r\n        let width = ref.current.clientWidth;\r\n        let height = ref.current.clientHeight;\r\n\r\n        if (width < 451 || height < 521) {\r\n            this.setState({\r\n                isMobile: true,\r\n            })\r\n        } else {\r\n            this.setState({\r\n                isMobile: false\r\n            })\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const { config } = this.props;\r\n        const { calendarList, isLoading, month, year, numDaysInMonth, isMobile, frameRef } = this.state;\r\n\r\n        if (isLoading) { return (<div />); }\r\n\r\n        // Patch for leap years since year value is dynamic.\r\n        config.numDaysInMonth = numDaysInMonth;\r\n        config.isMobile = isMobile;\r\n\r\n        return (\r\n            <div className='calendar-frame' ref={frameRef} style={{ height: config.height, width: config.width }}>\r\n                <CalendarFrame year={year} month={month} calendarList={calendarList} config={config} />\r\n                <ReactResizeDetector\r\n                    handleHeight\r\n                    handleWidth\r\n                    onResize={() => this.checkParentDimensions(frameRef)}\r\n                    refreshMode={'debounce'}\r\n                    refreshRate={200}\r\n                />\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport const EventCalendar = Calendar;\r\nexport const eventTypes = { PLACEHOLDER_TYPE, MULTI_DAY_TYPE, SINGLE_DAY_TYPE };\r\n"]},"metadata":{},"sourceType":"module"}